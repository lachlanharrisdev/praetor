Fully generated by AI, take it with a grain of salt. This is just a temporary file until this output system is much more integrated into the project.

---

# Output Formatter Utility

The `output.go` module provides a Docker-like standardized output formatting system for the Praetor application. It ensures all console output is consistently formatted with proper indentation, color coding, and icons.

## Features

- **Hierarchical Indentation**: Automatic indentation management for nested tasks and sub-steps
- **Color Coding**: Context-aware coloring based on output level and indentation
- **ASCII Icons**: Task, step, success, error, and warning indicators (no emojis)
- **Animated Loading Spinners**: Braille dot-based spinners for long-running operations
- **Thread-Safe**: All operations are protected by synchronization primitives
- **Color Utilities Integration**: Uses existing color utilities from `colour.go`

## Color Scheme

| Level | Root Indentation | Nested Indentation | Color |
|-------|------------------|-------------------|-------|
| **Primary** | Cyan/Bold | Dark Gray | Primary color for main tasks |
| **Success** | Green/Bold | Green/Bold | Always green for success |
| **Warning** | Yellow/Bold | Yellow/Bold | Always yellow for warnings |
| **Error** | Red/Bold | Red/Bold | Always red for errors |
| **Muted** | Dark Gray | Dark Gray | For sub-messages and low priority items |
| **Default** | White | White | Plain text with no special styling |

### Color Behavior Details

- **LevelPrimary** at indent level 0: Uses primary color (cyan/bold)
- **LevelPrimary** at indent level > 0: Uses muted color (dark gray) to indicate nesting
- **LevelSuccess, LevelWarning, LevelError**: Always use their respective colors regardless of indentation
- **LevelMuted**: Always dark gray, typically for sub-messages
- **LevelDefault**: Plain white text

## Icon Types

| Icon Type | ASCII | Usage |
|-----------|-------|-------|
| **IconArrow** | → | Main tasks and action items |
| **IconDash** | – | Sub-steps and nested items |
| **IconAccept** | ✓ | Successful completion |
| **IconReject** | ✗ | Failures and errors |
| **IconWarning** | ⚠ | Warnings and cautions |
| **IconLoader** | ⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏ | Animated spinner for loading states |
| **IconNone** | (none) | Plain message without icon |

### Spinner Animation

The loader uses braille Unicode characters (U+2800 through U+28FF) to create a smooth 10-frame animation:
- Frame duration: 100ms per frame (configurable via ticker)
- Total cycle time: ~1000ms
- Characters: ⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏

## API Reference

### Types

#### OutputLevel
```go
const (
    LevelDefault OutputLevel = iota  // White text
    LevelPrimary                      // Cyan/Bold (or dark gray if nested)
    LevelMuted                        // Dark gray
    LevelSuccess                      // Green/Bold
    LevelWarning                      // Yellow/Bold
    LevelError                        // Red/Bold
)
```

#### IconType
```go
const (
    IconNone IconType = iota
    IconDash                   // –
    IconArrow                  // →
    IconAccept                 // ✓
    IconReject                 // ✗
    IconWarning                // ⚠
    IconLoader                 // Animated spinner
)
```

### OutputFormatter Struct

The main struct managing output formatting. Use `NewOutputFormatter()` or `GetOutput()` to create instances.

**Key Methods:**

- `Log(level OutputLevel, iconType IconType, message string)` - Output a single message
- `Logf(level OutputLevel, iconType IconType, format string, args ...any)` - Output formatted message
- `StartLoader(id string, message string)` - Begin animated spinner
- `Indent()` - Increase indentation level
- `Dedent()` - Decrease indentation level
- `SetIndentLevel(level int)` - Set specific indentation level
- `GetIndentLevel()` - Get current indentation level
- `WithIndent(fn func())` - Temporarily increase indentation
- `WithIndentN(n int, fn func())` - Temporarily increase indentation by n levels

### Convenience Functions

Global functions that use the default formatter instance:

#### Logging Functions
```go
Log(level OutputLevel, iconType IconType, message string)
Logf(level OutputLevel, iconType IconType, format string, args ...any)
LogDefault(message string)
LogDefaultf(format string, args ...any)
LogPrimary(message string)
LogPrimaryf(format string, args ...any)
LogSuccess(message string)
LogSuccessf(format string, args ...any)
LogWarning(message string)
LogWarningf(format string, args ...any)
LogError(message string)
LogErrorf(format string, args ...any)
LogTask(message string)
LogTaskf(format string, args ...any)
LogStep(message string)
LogStepf(format string, args ...any)
```

#### Loader Functions
```go
StartLoader(id string, message string) func(OutputLevel, IconType, string)
```

Returns a stop function that accepts: `(finalLevel OutputLevel, finalIcon IconType, finalMessage string)`

#### Indentation Functions
```go
Indent()
Dedent()
SetIndentLevel(level int)
GetIndentLevel() int
WithIndent(fn func())
WithIndentN(n int, fn func())
```

#### Raw Output (for fallback)
```go
Println(args ...any)
Printlnf(format string, args ...any)
```

## Usage Examples

### Basic Task Logging

```go
package main

import "praetor/internal/utils"

func main() {
    utils.LogTask("Starting security scan")
    utils.LogStep("Initializing modules")
    utils.LogSuccess("Modules ready")
}
```

Output:
```
→ Starting security scan
– Initializing modules
✓ Modules ready
```

### Indented Nested Tasks

```go
utils.LogTask("Scanning network")
utils.Indent()
{
    utils.LogStep("Discovering hosts")
    utils.LogSuccess("Found 5 hosts")
    
    utils.LogTask("Testing connectivity")
    utils.Indent()
    {
        utils.LogStep("Pinging 192.168.1.1")
        utils.LogSuccess("Response received")
    }
    utils.Dedent()
}
utils.Dedent()
```

Output:
```
→ Scanning network
  – Discovering hosts
  ✓ Found 5 hosts
  → Testing connectivity
    – Pinging 192.168.1.1
    ✓ Response received
```

Note: At indent level 1+, the arrow/dash items are shown in muted (dark gray) color.

### Using Loading Spinners

```go
utils.LogTask("Processing data")
stopLoader := utils.StartLoader("process-id", "Processing...")

// Do work...
time.Sleep(2 * time.Second)

stopLoader(utils.LevelSuccess, utils.IconAccept, "Processing complete")
```

Output:
```
→ Processing data
⠋ Processing...  (animates)
✓ Processing complete
```

### Using WithIndent Helper

```go
utils.LogTask("Building")
utils.WithIndent(func() {
    utils.LogStep("Step 1")
    utils.LogStep("Step 2")
    utils.LogStep("Step 3")
})
utils.LogSuccess("Build complete")
```

The indentation is automatically restored after the callback.

### Formatted Messages

```go
count := 42
utils.LogTaskf("Found %d vulnerabilities", count)
utils.Indent()
{
    for i := 1; i <= 3; i++ {
        utils.LogStepf("Checking vulnerability %d/%d", i, 3)
    }
}
utils.Dedent()
```

### Multiple Loaders (Sequential)

```go
// First loader
stop1 := utils.StartLoader("task1", "Task 1 running...")
time.Sleep(1 * time.Second)
stop1(utils.LevelSuccess, utils.IconAccept, "Task 1 done")

// Second loader (safe to start after first completes)
stop2 := utils.StartLoader("task2", "Task 2 running...")
time.Sleep(1 * time.Second)
stop2(utils.LevelSuccess, utils.IconAccept, "Task 2 done")
```

**Note:** Only one loader can be animated at a time. Sequential calls are safe; concurrent calls will be managed by the mutex.

### Custom OutputFormatter Instance

```go
import "os"

formatter := utils.NewOutputFormatter(os.Stdout)
formatter.LogTask("Custom instance")
formatter.Indent()
{
    formatter.LogStep("Step 1")
    formatter.LogSuccess("Done")
}
formatter.Dedent()
```

### Error Handling Pattern

```go
utils.LogTask("Connecting to server")
stopLoader := utils.StartLoader("connect", "Connecting...")
time.Sleep(1 * time.Second)

if err != nil {
    stopLoader(utils.LevelError, utils.IconReject, "Connection failed")
    utils.LogError("Reason: " + err.Error())
} else {
    stopLoader(utils.LevelSuccess, utils.IconAccept, "Connected")
}
```

## Thread Safety

All operations are protected by `sync.RWMutex`, making the formatter safe for concurrent use:

```go
go func() {
    utils.LogTask("Task 1")
}()

go func() {
    utils.LogStep("Step 2")
}()

utils.LogSuccess("Both safe")
```

The mutex ensures:
- Write operations (Indent, Dedent, Log) are serialized
- Read operations (GetIndentLevel) don't block writes unnecessarily
- Loader state updates are atomic

## Indentation Management

### Methods for Managing Indentation

1. **Direct Methods** (for manual control):
   ```go
   utils.Indent()      // Increase by 1
   utils.Dedent()      // Decrease by 1
   utils.SetIndentLevel(2)  // Set to specific level
   level := utils.GetIndentLevel()  // Get current
   ```

2. **Helper Methods** (for automatic restoration):
   ```go
   utils.WithIndent(func() {
       // Code here runs at indented level
       // Automatically dedented when function returns
   })
   
   utils.WithIndentN(3, func() {
       // Code here runs at +3 indent levels
       // Automatically dedented when function returns
   })
   ```

### Best Practices

- Use `WithIndent()` or `WithIndentN()` to ensure proper restoration
- Use direct methods when you need manual control over multiple scopes
- Always pair `Indent()` calls with `Dedent()` calls (use defer if needed)
- Consider using `SetIndentLevel(0)` at logical section boundaries

## Implementation Details

### Braille Spinner Frames

The loader animation uses Unicode braille patterns (U+2800 range) for a smooth visual effect:
- 10 distinct frames
- 100ms per frame = ~1 second full cycle
- Works in any terminal that supports Unicode
- No emoji fallback required (uses pure ASCII braille)

### ANSI Escape Sequences

The formatter uses standard ANSI escape codes:
- `\r` - Carriage return (move cursor to line start)
- `\033[K` - Clear to end of line (for cleaning loader animation)

### Color Integration

Colors are provided by the `colour.go` module using the `fatih/color` package:
- `Primary()` - Cyan/Bold at root, inherited at nested
- `Muted()` - Dark gray, intentionally not bold
- `Accept()` - Green/Bold
- `Warning()` - Yellow/Bold
- `Error()` - Red/Bold
- `Default()` - Standard terminal color

## Performance Considerations

- **Mutex Contention**: Minimal impact due to RWMutex usage
- **Memory**: Each active loader uses minimal memory (~128 bytes)
- **Goroutines**: One animation goroutine per active loader
- **Ticker**: Global ticker if loaders are active (100ms granularity)

## Compatibility

- **Go Version**: 1.16+
- **Terminals**: Any ANSI-compatible terminal (Windows 10+, macOS, Linux)
- **Unicode Support**: Requires UTF-8 capable terminal for braille characters
- **Color**: Respects `NO_COLOR` environment variable through `colour.go`

## Migration from Raw Prints

Replace raw `fmt.Println()` calls with structured logging:

**Before:**
```go
fmt.Println("Starting scan")
fmt.Println("  Checking host 1")
fmt.Println("  Checking host 2")
fmt.Println("Scan complete")
```

**After:**
```go
utils.LogTask("Starting scan")
utils.Indent()
{
    utils.LogStep("Checking host 1")
    utils.LogStep("Checking host 2")
}
utils.Dedent()
utils.LogSuccess("Scan complete")
```

Benefits:
- Automatic formatting and coloring
- Consistent structure across codebase
- Easier to refactor and maintain
- Professional appearance

## Troubleshooting

### Loader Not Animating
- Ensure terminal supports ANSI escape sequences
- Check that `NO_COLOR` is not set if you want colors
- Verify at least 100ms passes between checks

### Colors Not Showing
- Check `NO_COLOR` environment variable
- Ensure terminal has color support (256+ colors)
- Verify colors are enabled via `colour.ConfigureTerminal()`

### Garbled Output
- Ensure output is not being piped through non-UTF8-aware tools
- Check terminal encoding is UTF-8
- Verify braille characters are supported

### Race Conditions
- All global functions are thread-safe
- If using custom formatter, ensure access is serialized at call site
- Use `WithIndent()` instead of manual Indent/Dedent in goroutines

## Examples File

See `output_example.go` for comprehensive usage examples including:
- Basic logging patterns
- Docker-style output
- Deep nesting scenarios
- Error handling
- Formatted messages
- Multiple loaders
- Indent level management
